// /home/ubuntu/Mail_Project/backend/server.js
const express = require("express");
const mysql = require("mysql2");
const bcrypt = require("bcryptjs");
const cors = require("cors");

const app = express();
app.use(express.json());
app.use(cors());

// Disable cache
app.use((req, res, next) => {
  res.setHeader("Cache-Control", "no-store");
  next();
});

// -----------------------------------
// MYSQL (use a pool to avoid closed-connection errors)
// -----------------------------------
const pool = mysql.createPool({
  host: "localhost",
  user: "mailusers",
  password: "StrongPassword123!",
  database: "maildb",
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  // optional keepAlive settings:
  enableKeepAlive: true,
  keepAliveInitialDelay: 0,
});

// convenience promise wrapper
const db = pool.promise();

async function testDb() {
  try {
    await db.query("SELECT 1");
    console.log("MySQL Pool connected");
  } catch (e) {
    console.error("MySQL pool test failed:", e && e.message);
  }
}
testDb();

// graceful error handling
pool.on && pool.on('error', (err) => {
  console.error("MySQL pool error event:", err);
});

// -----------------------------------
// CREATE SYSTEM FOLDERS (ONLY ONCE)
// Uses INSERT ... ON DUPLICATE KEY UPDATE to avoid duplicates
// -----------------------------------
async function createSystemFolders(userId) {
  const folders = [
    ["Inbox", "inbox"],
    ["Sent", "sent"],
    ["Drafts", "drafts"],
    ["Spam", "spam"],
    ["Trash", "trash"],
    ["Starred", "starred"]
  ];

  // ensure unique constraint exists on (user_id, system_box) - recommended to run the SQL provided in README
  const promises = folders.map(([name, system]) =>
    // insert but do nothing if already present
    db.query(
      `INSERT INTO mailboxes (user_id, name, system_box)
       VALUES (?, ?, ?)
       ON DUPLICATE KEY UPDATE name = VALUES(name)`,
      [userId, name, system]
    ).catch(err => {
      // log but continue
      console.error("createSystemFolders insert error:", { userId, name, system, message: err && err.message });
    })
  );

  await Promise.all(promises);
}

// -----------------------------------
// REGISTER
// -----------------------------------
app.post("/api/register", async (req, res) => {
  const { name, email, password } = req.body;

  try {
    const hashed = await bcrypt.hash(password, 10);

    const [result] = await db.query(
      "INSERT INTO users (name, email, password) VALUES (?, ?, ?)",
      [name, email, hashed]
    );

    const userId = result.insertId;
    await createSystemFolders(userId);

    res.json({ user: { id: userId, name, email } });
  } catch (e) {
    console.error("REGISTER ERROR:", e && e.message);
    res.status(500).json({ error: "Registration failed", details: e && e.message });
  }
});

// -----------------------------------
// CHECK IF EMAIL EXISTS
// -----------------------------------
app.get("/api/users/email/:email", async (req, res) => {
  const email = decodeURIComponent(req.params.email);
  try {
    const [rows] = await db.query("SELECT id, name, email FROM users WHERE email = ? LIMIT 1", [email]);
    if (!rows.length) return res.json({ exists: false });
    return res.json({ exists: true, user: rows[0] });
  } catch (err) {
    console.error("CHECK EMAIL ERROR:", err && err.message);
    return res.status(500).json({ error: err && err.message });
  }
});

// -----------------------------------
// LOGIN
// -----------------------------------
app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;
  try {
    const [rows] = await db.query("SELECT * FROM users WHERE email = ?", [email]);
    if (!rows.length) return res.json({ error: "User not found" });

    const user = rows[0];
    const match = await bcrypt.compare(password, user.password);
    if (!match) return res.json({ error: "Incorrect password" });

    await createSystemFolders(user.id);

    res.json({
      user: {
        id: user.id,
        name: user.name,
        email: user.email
      }
    });
  } catch (err) {
    console.error("LOGIN ERROR:", err && err.message);
    res.status(500).json({ error: err && err.message });
  }
});

// -----------------------------------
// GET FOLDERS
// -----------------------------------
app.get("/api/folders/:userId", async (req, res) => {
  try {
    const [rows] = await db.query(
      `SELECT id, name, system_box FROM mailboxes 
       WHERE user_id=? ORDER BY id ASC`,
      [req.params.userId]
    );
    res.json({ data: rows });
  } catch (err) {
    console.error("GET FOLDERS ERROR:", err && err.message);
    res.status(500).json({ error: err && err.message });
  }
});

// -----------------------------------
// GET EMAILS IN FOLDER
// -----------------------------------
app.get("/api/emails/:userId/:folderId", async (req, res) => {
  const rawUserId = req.params.userId;
  const rawFolderId = req.params.folderId;

  // Basic validation - folderId must be numeric id (server design expects numeric mailbox id)
  const userId = Number(rawUserId);
  const folderId = Number(rawFolderId);

  if (!Number.isInteger(userId) || userId <= 0) {
    console.error("Invalid userId in /api/emails:", { rawUserId });
    return res.status(400).json({ error: "invalid userId" });
  }
  if (!Number.isInteger(folderId) || folderId <= 0) {
    console.error("Invalid folderId in /api/emails:", { rawFolderId });
    return res.status(400).json({ error: "invalid folderId" });
  }

  const sql = `
    SELECT e.*, m.is_read, m.is_starred
    FROM emails e
    JOIN email_mailbox m ON e.id = m.email_id
    WHERE m.user_id = ? AND m.mailbox_id = ?
    ORDER BY e.created_at DESC
  `;

  try {
    const [rows] = await db.query(sql, [userId, folderId]);
    res.json({ data: Array.isArray(rows) ? rows : [] });
  } catch (err) {
    console.error("DB error while fetching emails:", {
      userId,
      mailboxId: folderId,
      message: err && err.message,
      code: err && err.code,
      sqlMessage: err && err.sqlMessage,
      stack: err && err.stack
    });
    return res.status(500).json({ error: "Failed to load emails", details: err && err.message });
  }
});

// -----------------------------------
// CREATE EMAIL
// -----------------------------------
app.post("/api/email/create", async (req, res) => {
  const { user_id, to, cc, bcc, subject, body, folder_id } = req.body;

  try {
    const [result] = await db.query(
      `INSERT INTO emails (user_id, subject, body) VALUES (?, ?, ?)`,
      [user_id, subject, body]
    );

    const emailId = result.insertId;

    const recipients = [
      [emailId, to, "to"],
      [emailId, cc, "cc"],
      [emailId, bcc, "bcc"]
    ];

    for (const r of recipients) {
      if (r[1]) {
        // handle string or array: if array, store as multiple rows
        if (Array.isArray(r[1])) {
          for (const addr of r[1]) {
            await db.query(`INSERT INTO email_recipients (email_id, address, type) VALUES (?, ?, ?)`, [r[0], addr, r[2]]);
          }
        } else {
          await db.query(`INSERT INTO email_recipients (email_id, address, type) VALUES (?, ?, ?)`, r);
        }
      }
    }

    await db.query(
      `INSERT INTO email_mailbox (user_id, email_id, mailbox_id)
       VALUES (?, ?, ?)`,
      [user_id, emailId, folder_id]
    );

    res.json({ message: "Email created", emailId });
  } catch (err) {
    console.error("CREATE EMAIL ERROR:", err && err.message);
    res.status(500).json({ error: err && err.message });
  }
});

// Move email to a different mailbox
app.post('/api/email/move', async (req, res) => {
  const { email_id, user_id, target_folder } = req.body;
  if (!email_id || !user_id || !target_folder) return res.status(400).json({ error: 'missing params' });

  try {
    await db.query(
      `UPDATE email_mailbox SET mailbox_id = ? WHERE email_id = ? AND user_id = ?`,
      [target_folder, email_id, user_id]
    );
    return res.json({ ok: true });
  } catch (err) {
    console.error("MOVE EMAIL ERROR:", err && err.message);
    return res.status(500).json({ error: err && err.message });
  }
});

// Delete (move to Trash)
app.post('/api/email/delete', async (req, res) => {
  const { email_id, user_id } = req.body;
  if (!email_id || !user_id) return res.status(400).json({ error: 'missing' });

  try {
    const [rows] = await db.query(`SELECT id FROM mailboxes WHERE user_id=? AND system_box='trash' LIMIT 1`, [user_id]);
    if (!rows.length) return res.status(500).json({ error: 'no trash mailbox' });
    const trashId = rows[0].id;
    await db.query(`UPDATE email_mailbox SET mailbox_id=? WHERE email_id=? AND user_id=?`, [trashId, email_id, user_id]);
    return res.json({ ok: true });
  } catch (err) {
    console.error("DELETE EMAIL ERROR:", err && err.message);
    return res.status(500).json({ error: err && err.message });
  }
});

// Star/unstar
app.post('/api/email/star', async (req, res) => {
  const { email_id, user_id, status } = req.body;
  if (!email_id || !user_id) return res.status(400).json({ error: 'missing' });

  try {
    await db.query(
      `UPDATE email_mailbox SET is_starred = ? WHERE email_id = ? AND user_id = ?`,
      [status ? 1 : 0, email_id, user_id]
    );
    return res.json({ ok: true });
  } catch (err) {
    console.error("STAR EMAIL ERROR:", err && err.message);
    return res.status(500).json({ error: err && err.message });
  }
});

// Mark read/unread
app.post('/api/email/read', async (req, res) => {
  const { email_id, user_id, is_read } = req.body;
  try {
    await db.query(`UPDATE email_mailbox SET is_read=? WHERE email_id=? AND user_id=?`, [is_read?1:0, email_id, user_id]);
    res.json({ ok: true });
  } catch (err) {
    console.error("READ EMAIL ERROR:", err && err.message);
    res.status(500).json({ error: err && err.message });
  }
});

// -----------------------------------
// Compatibility: accept legacy POST /api/users
// forwards to /api/register (internal call)
app.post('/api/users', async (req, res) => {
  try {
    // call local handler directly to avoid network roundtrip
    // reuse register logic: call createUser flow
    // For simplicity call register endpoint via internal fetch (works), but ensure localhost:3000 is reachable
    const rsp = await fetch('http://127.0.0.1:3000/api/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req.body),
    });

    const text = await rsp.text();
    try {
      const json = JSON.parse(text);
      return res.status(rsp.status).json(json);
    } catch (e) {
      res.status(rsp.status).send(text);
    }
  } catch (err) {
    console.error('Error forwarding /api/users to /api/register:', err && err.message);
    res.status(500).json({ error: 'internal', details: err && err.message });
  }
});

app.listen(3000, () => console.log("Backend running on port 3000"));
